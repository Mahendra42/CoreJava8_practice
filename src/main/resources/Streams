forEach() -- is from iterable interface which is extending by collection and map interfaces.
stream() -- is a default method in collection interface.

Some Array methods used for creating streams.
Stream Creation from arrays : Arrays.stream([] multiple data types).
List creation from arrays : Arrays.asList(...values).

we can call stream() on all the collection and collection implementation classes.

we cannot call stream() on Map interface and its implementation classes.

- The class Collectors provides implementations of many common mutable reductions.


Java.util.Streams :
-------------------
- Stream does not store elements.
- It simply conveys elements from a source such as a data structure, an array, or an I/O channel, through a pipeline of computational operations.
- Stream is functional in nature. Operations performed on a stream do not modify its source.
    For example, filtering a Stream obtained from a collection produces a new Stream without the filtered elements, rather than removing elements from the source collection.
- Stream is lazy and evaluates code only when required.
- The elements of a stream are only visited once during the life of a stream. Like an Iterator,
    a new stream must be generated to revisit the same elements of the source.

- You can use Stream to filter, collect, print, and convert from one data structure to other etc.

STATIC METHODS :
----------------
static <T> Stream.Builder<T> builder() -- Returns a builder for a Stream.
static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b) -- Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
static <T> Stream<T> empty() -- Returns an empty sequential Stream.
static <T> Stream<T> generate(Supplier<T> s) -- Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.
static <T> Stream<T> iterate(T seed, UnaryOperator<T> f) -- Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.
static <T> Stream<T> of(T... values) -- Returns a sequential ordered stream whose elements are the specified values.
static <T> Stream<T> of(T t) -- Returns a sequential Stream containing a single element.

INSTANCE METHODS :
--------------------
- allMatch(Predicate<? super T> predicate)
- anyMatch(Predicate<? super T> predicate)
- collect(Collector<? super T,A,R> collector)
- collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)
- count()
- distinct()
- filter(Predicate<? super T> predicate)
- findAny()
- findFirst()
- flatMap(Function<? super T,? extends Stream<? extends R>> mapper)
- flatMapToDouble(Function<? super T,? extends DoubleStream> mapper)
- flatMapToInt(Function<? super T,? extends IntStream> mapper)
- flatMapToLong(Function<? super T,? extends LongStream> mapper)
- forEach(Consumer<? super T> action)
- forEachOrdered(Consumer<? super T> action)
- limit(long maxSize)
- map(Function<? super T,? extends R> mapper)
- mapToDouble(ToDoubleFunction<? super T> mapper)
- mapToInt(ToIntFunction<? super T> mapper)
- mapToLong(ToLongFunction<? super T> mapper)
- max(Comparator<? super T> comparator)
- min(Comparator<? super T> comparator)
- noneMatch(Predicate<? super T> predicate)
- peek(Consumer<? super T> action)
- reduce(BinaryOperator<T> accumulator)
- reduce(T identity, BinaryOperator<T> accumulator)
- reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)
- skip(long n)
- sorted()
- sorted(Comparator<? super T> comparator)	toArray()
- toArray(IntFunction<A[]> generator)

and some default and abstarct methods are there ..please refer the JAVA 8 API Documentation.
